
==================== src/core/anvil.rs ====================
use std::sync::Arc;
use std::ops::Div;
use anyhow::Result;
use alloy::providers::Provider;
use alloy::{
    node_bindings::Anvil,
    primitives::U256,
    providers::{ProviderBuilder, RootProvider},
    transports::http::reqwest::Url,
};

use crate::types::{ChainConfig, ONE_ETHER};
use crate::source::{builder::volumes, abi::*, builder::build_tx};
use crate::core::logger::{measure_start, measure_end};

/// Ch·∫°y m√¥ ph·ªèng quote th√¥ng qua Anvil forked mainnet
/// ‚Üí C√≥ th·ªÉ so s√°nh v·ªõi eth_call ho·∫∑c revm ƒë·ªÉ ki·ªÉm tra k·∫øt qu·∫£ gi·ªëng th·ª±c t·∫ø
pub async fn run_eth_anvil(config: &ChainConfig) -> Result<()> {
    // 1Ô∏è‚É£ Parse RPC URL v√† kh·ªüi t·∫°o provider th·∫≠t
    let rpc_url = config.rpc_url.parse::<Url>()?;
    let provider = ProviderBuilder::new().on_http(rpc_url.clone());
    let provider = Arc::new(provider);

    // 2Ô∏è‚É£ L·∫•y base_fee v√† block height ƒë·ªÉ t·∫°o fork
    let base_fee = provider.get_gas_price().await?;
    let fork_block = provider.get_block_number().await?;

    // 3Ô∏è‚É£ T·∫°o instance Anvil fork t·ª´ block th·ª±c
    let anvil = Anvil::new()
        .fork(rpc_url)
        .fork_block_number(fork_block)
        .block_time(1_u64)
        .spawn();

    // 4Ô∏è‚É£ T·∫°o provider k·∫øt n·ªëi ƒë·∫øn Anvil local fork
    let anvil_provider = ProviderBuilder::new()
        .on_http(anvil.endpoint().parse::<Url>()?);
    let anvil_provider = Arc::new(anvil_provider);

    // 5Ô∏è‚É£ L·∫•y th√¥ng tin token / quoter / from t·ª´ config
    let from = config.addr("ME")?;
    let token_in = config.addr("WETH")?;
    let token_out = config.addr("USDC")?;
    let quoter = config.addr("QUOTER")?;

    // 6Ô∏è‚É£ Chu·∫©n b·ªã volumes ƒë·ªÉ benchmark
    let volumes = volumes(U256::ZERO, ONE_ETHER.div(U256::from(10)), 100);

    // 7Ô∏è‚É£ Quote l·∫ßn ƒë·∫ßu
    let start = measure_start("anvil_first");
    let calldata = quote_calldata(token_in, token_out, volumes[0], 3000);
    let tx = build_tx(quoter, from, calldata, base_fee);
    let response = anvil_provider.call(&tx).await?;
    let amount_out = decode_quote_response(response)?;
    println!("{} WETH -> USDC {}", volumes[0], amount_out);
    measure_end(start);

    // 8Ô∏è‚É£ Loop ƒë·ªÉ benchmark nhi·ªÅu volume
    let start = measure_start("anvil_loop");
    for (index, volume) in volumes.into_iter().enumerate() {
        let calldata = quote_calldata(token_in, token_out, volume, 3000);
        let tx = build_tx(quoter, from, calldata, base_fee);
        let response = anvil_provider.call(&tx).await?;
        let amount_out = decode_quote_response(response)?;
        if index % 20 == 0 {
            println!("{} WETH -> USDC {}", volume, amount_out);
        }
    }
    measure_end(start);

    drop(anvil); // cleanup anvil instance

    Ok(())
}



==================== src/core/arbitrage.rs ====================
use std::sync::Arc;
use std::{ops::Div, str::FromStr};

use alloy::signers::k256::elliptic_curve::consts::U2;
use anyhow::Result;
use alloy::{
    primitives::{Bytes, U256},
    providers::ProviderBuilder,
};
use revm::primitives::Bytecode;

use crate::types::{ChainConfig, ONE_ETHER};
use crate::source::{abi::*, builder::volumes};
use crate::core::db::*;

/// M√¥ ph·ªèng back-and-forth arbitrage WETH -> USDC -> WETH
/// D√πng custom UniV3Quoter ƒë·ªÉ quote offchain qua REVM
pub async fn run_eth_arbitrage(config: &ChainConfig) -> Result<()> {
    let provider = ProviderBuilder::new()
        .on_http(config.rpc_url.parse()?);
    let provider = Arc::new(provider);
    // T·∫°o REVM cache database t·ª´ provider

    let mut cache_db = init_cache_db(provider.clone());

    let from = config.addr("ME")?;
    let token_in = config.addr("WETH")?;
    let token_out = config.addr("USDC")?;
    let pool1 = config.addr("POOL_500")?;
    let pool2 = config.addr("POOL_3000")?;
    let quoter = config.addr("CUSTOM_QUOTER")?;

    let mocked_erc20 = include_str!("../bytecode/generic_erc20.hex");
    let mocked_erc20 = Bytecode::new_raw(Bytes::from_str(mocked_erc20)?);

    let mocked_quoter = include_str!("../bytecode/uni_v3_quoter.hex");
    let mocked_quoter = Bytecode::new_raw(Bytes::from_str(mocked_quoter)?);

    // Kh·ªüi t·∫°o REVM state cho quoter, pool, token
    init_account(from, &mut cache_db, provider.clone()).await?;
    init_account(pool1, &mut cache_db, provider.clone()).await?;
    init_account(pool2, &mut cache_db, provider.clone()).await?;

    init_account_with_bytecode(token_in, mocked_erc20.clone(), &mut cache_db)?;
    init_account_with_bytecode(token_out, mocked_erc20.clone(), &mut cache_db)?;
    init_account_with_bytecode(quoter, mocked_quoter, &mut cache_db)?;

    let mocked_balance = U256::MAX.div(U256::from(2));
    for &pool in &[pool1, pool2] {
        insert_mapping_storage_slot(token_in, U256::ZERO, pool, mocked_balance, &mut cache_db)?;
        insert_mapping_storage_slot(token_out, U256::ZERO, pool, mocked_balance, &mut cache_db)?;
    }

    // Loop t·ª´ng volume ƒë·ªÉ ki·ªÉm tra arbitrage
    let vols = volumes(U256::ZERO, ONE_ETHER.div(U256::from(10)), 100);
    for vol in vols {
        let calldata1 = get_amount_out_calldata(pool1, token_in, token_out, vol);
        let resp1 = revm_revert(from, quoter, calldata1, &mut cache_db)?;
        let token_out_amount = decode_get_amount_out_response(resp1)?;

        let calldata2 = get_amount_out_calldata(pool2, token_out, token_in, U256::from(token_out_amount));
        let resp2 = revm_revert(from, quoter, calldata2, &mut cache_db)?;
        let token_in_back = decode_get_amount_out_response(resp2)?;
        let token_in_back = U256::from(token_in_back);

        println!(
            "{} WETH ‚Üí USDC {} ‚Üí WETH {}",
            vol, token_out_amount, token_in_back
        );

        if token_in_back > vol {
            let profit = token_in_back - vol;
            println!("‚úÖ Arbitrage profit: {} WETH", profit);
        } else {
            println!("‚ùå No profit");
        }
    }

    Ok(())
}



==================== src/core/call.rs ====================
use std::sync::Arc;
use std::ops::Div;
use anyhow::Result;
use alloy::{
    primitives::U256,
    providers::{Provider, ProviderBuilder},
};
use crate::types::ChainConfig;
use crate::source::{builder::*, abi::*};
use crate::core::logger::{measure_start, measure_end};

pub async fn run_eth_call(config: &ChainConfig) -> Result<()> {
    // Setup provider
    let provider = ProviderBuilder::new()
        .on_http(config.rpc_url.parse()?);
    let provider = Arc::new(provider);

    // L·∫•y base fee
    let base_fee = provider.get_gas_price().await?;
    let from = config.addr("ME")?;
    let token_in = config.addr("WETH")?;
    let token_out = config.addr("USDC")?;
    let quoter = config.addr("QUOTER")?;

    // Chu·∫©n b·ªã volumes
    let volumes = volumes(U256::ZERO, crate::types::ONE_ETHER.div(U256::from(10)), 100);

    let start = measure_start("eth_call");

    for (index, volume) in volumes.into_iter().enumerate() {
        let calldata = quote_calldata(token_in, token_out, volume, 3000);
        let tx = build_tx(quoter, from, calldata, base_fee);
        let response = provider.call(&tx).await?;
        let amount_out = decode_quote_response(response)?;

        if index % 20 == 0 {
            println!("{} WETH -> USDC {}", volume, amount_out);
        }
    }

    measure_end(start);
    Ok(())
}




==================== src/core/chain_call.rs ====================
use std::sync::Arc;
use std::ops::Div;
use anyhow::Result;
use alloy::{
    eips::BlockId,
    primitives::U256,
    providers::{Provider, ProviderBuilder},
};
use crate::{source::build_tx_avalanche, types::{ChainConfig, ONE_ETHER}};
use crate::source::{builder::volumes, abi::quote_calldata, builder::build_tx};
use crate::core::logger::{measure_start, measure_end};
use crate::chain::actors::ChainActors;

/// M√¥ ph·ªèng quote swap b·∫±ng eth_call (multi-chain)
pub async fn run_chain_call(config: &ChainConfig, actors: &ChainActors) -> Result<()> {
    let provider = ProviderBuilder::new()
        .on_http(config.rpc_url.parse()?);
    let provider = Arc::new(provider);

    let base_fee = provider.get_gas_price().await?;
    let from = config.addr("ME")?;
    let token_in = config.addr(actors.native_token_key)?;
    let token_out = config.addr(actors.stable_token_key)?;
    let quoter = config.addr(actors.quoter_key)?;

    // print address 
    // println!("From address: {}", from);
    // println!("Token in address: {}", token_in);
    // println!("Token out address: {}", token_out);
    // println!("Quoter address: {}", quoter);

    let volumes = volumes(U256::ZERO, ONE_ETHER.div(U256::from(10)), 100);

    let start = measure_start("chain_call");

    for (index, volume) in volumes.into_iter().enumerate() {
        let calldata = quote_calldata(token_in, token_out, volume, actors.default_fee);
        
        let tx = build_tx(quoter, from, calldata, base_fee);

        // println!("\nTransaction: {:?}", tx);
        // println!("Calling provider with transaction...");

        // let response = provider.call(&tx).await?;
        let response = provider.call(&tx).block(BlockId::latest()).await?;

        let amount_out = crate::source::abi::decode_quote_response(response)?;

        // println!("Response: {:?}", response);
        // println!("Amount out: {}", amount_out);

        if index % 20 == 0 {
            println!(
                "{} {} -> {} {}",
                volume, actors.native_token_key, actors.stable_token_key, amount_out
            );
        }
    }

    measure_end(start);
    Ok(())
}



==================== src/core/db.rs ====================
use alloy::{
    network::Ethereum,
    primitives::{keccak256, Address, Bytes, U256},
    providers::{Provider, RootProvider},
    sol_types::SolValue,
    transports::http::{Client, Http},
};
use anyhow::{anyhow, Result};
use revm::{
    db::{AlloyDB, CacheDB},
    primitives::{AccountInfo, Bytecode, ExecutionResult, Output, TransactTo},
    Evm,
};
use std::sync::Arc;

pub type AlloyCacheDB =
    CacheDB<AlloyDB<Http<Client>, Ethereum, Arc<RootProvider<Http<Client>>>>>;

pub fn init_cache_db(provider: Arc<RootProvider<Http<Client>>>) -> AlloyCacheDB {
    CacheDB::new(AlloyDB::new(provider, Default::default()).unwrap())
}

pub async fn init_account(
    address: Address,
    cache_db: &mut AlloyCacheDB,
    provider: Arc<RootProvider<Http<Client>>>,
) -> Result<()> {
    let cache_key = format!("bytecode-{:?}", address);
    let bytecode = match cacache::read(&cache_dir(), cache_key.clone()).await {
        Ok(bytecode) => {
            let bytecode = Bytes::from(bytecode);
            Bytecode::new_raw(bytecode)
        }
        Err(_) => {
            let bytecode = provider.get_code_at(address).await?;
            let bytecode_result = Bytecode::new_raw(bytecode.clone());
            let bytecode_vec = bytecode.to_vec();
            cacache::write(&cache_dir(), cache_key, bytecode_vec).await?;
            bytecode_result
        }
    };
    let code_hash = bytecode.hash_slow();
    let acc_info = AccountInfo {
        balance: U256::ZERO,
        nonce: 0_u64,
        code: Some(bytecode),
        code_hash,
    };
    cache_db.insert_account_info(address, acc_info);
    Ok(())
}

pub fn init_account_with_bytecode(
    address: Address,
    bytecode: Bytecode,
    cache_db: &mut AlloyCacheDB,
) -> Result<()> {
    let code_hash = bytecode.hash_slow();
    let acc_info = AccountInfo {
        balance: U256::ZERO,
        nonce: 0_u64,
        code: Some(bytecode),
        code_hash,
    };
    cache_db.insert_account_info(address, acc_info);
    Ok(())
}

pub fn insert_mapping_storage_slot(
    contract: Address,
    slot: U256,
    slot_address: Address,
    value: U256,
    cache_db: &mut AlloyCacheDB,
) -> Result<()> {
    let hashed_slot = keccak256((slot_address, slot).abi_encode());
    cache_db.insert_account_storage(contract, hashed_slot.into(), value)?;
    Ok(())
}

pub fn revm_call(
    from: Address,
    to: Address,
    calldata: Bytes,
    cache_db: &mut AlloyCacheDB,
) -> Result<Bytes> {
    let mut evm = Evm::builder()
        .with_db(cache_db)
        .modify_tx_env(|tx| {
            tx.caller = from;
            tx.transact_to = TransactTo::Call(to);
            tx.data = calldata;
            tx.value = U256::ZERO;
        })
        .build();

    let result = evm.transact()?.result;

    let value = match result {
        ExecutionResult::Success {
            output: Output::Call(value),
            ..
        } => value,
        result => {
            return Err(anyhow!("execution failed: {result:?}"));
        }
    };

    Ok(value)
}

pub fn revm_revert(
    from: Address,
    to: Address,
    calldata: Bytes,
    cache_db: &mut AlloyCacheDB,
) -> Result<Bytes> {
    let mut evm = Evm::builder()
        .with_db(cache_db)
        .modify_tx_env(|tx| {
            tx.caller = from;
            tx.transact_to = TransactTo::Call(to);
            tx.data = calldata;
            tx.value = U256::ZERO;
        })
        .build();

    let result = evm.transact()?.result;

    match result {
        ExecutionResult::Revert { output, .. } => Ok(output),
        _ => Err(anyhow!("Expected revert result")),
    }
}

fn cache_dir() -> String {
    ".evm_cache".to_string()
}



==================== src/core/logger.rs ====================
use std::time::Instant;
use std::fs::{OpenOptions};
use std::io::Write;
use serde::Serialize;

/// ƒêo th·ªùi gian b·∫Øt ƒë·∫ßu
pub fn measure_start(label: &str) -> (String, Instant) {
    (label.to_string(), Instant::now())
}

/// ƒêo th·ªùi gian k·∫øt th√∫c v√† in ra stdout
pub fn measure_end(start: (String, Instant)) {
    let elapsed = start.1.elapsed();
    println!("Elapsed: {:.2?} for '{}'", elapsed, start.0);
}

/// C·∫•u tr√∫c JSON log k·∫øt qu·∫£ quote
#[derive(Serialize)]
pub struct QuoteLog {
    pub chain: String,
    pub method: String,
    pub volume: String,
    pub from_token: String,
    pub to_token: String,
    pub amount_out: String,
    pub elapsed_ms: u128,
}

/// Log quote ra stdout v√† file (tu·ª≥ ch·ªçn)
pub fn log_quote(log: QuoteLog) {
    let json = serde_json::to_string(&log).unwrap();
    println!("{json}");

    let mut file = OpenOptions::new()
        .append(true)
        .create(true)
        .open("output/quote.jsonl")
        .unwrap();

    writeln!(file, "{json}").unwrap();
}



==================== src/core/mod.rs ====================
pub mod call;
pub mod revm;
pub mod anvil;     // ch·ª©a init_cache_db, init_account, v.v.
pub mod revm_cached; // ch·ª©a run_eth_revm_cached, v.v.
pub mod revm_quoter; // ch·ª©a run_eth_revm_quoter, v.v.
pub mod validate;
pub mod arbitrage;

pub mod chain_call;
pub mod db;        // ch·ª©a init_cache_db, init_account, v.v.
pub mod logger;    // ch·ª©a measure_start, structured log, ...



==================== src/core/revm_cached.rs ====================
use std::sync::Arc;
use std::ops::Div;
use std::str::FromStr;
use anyhow::Result;
use alloy::{
    primitives::{Bytes, U256},
    providers::ProviderBuilder,
};
use revm::primitives::Bytecode;

use crate::types::{ChainConfig, ONE_ETHER};
use crate::source::{builder::volumes, abi::*};
use crate::core::db::*;
use crate::core::logger::{measure_start, measure_end};

/// REVM m√¥ ph·ªèng UniswapV3 v·ªõi d·ªØ li·ªáu cache:
/// - G√°n bytecode ERC20 gi·∫£ cho token
/// - Th√™m balance th·ªß c√¥ng v√†o REVM storage
pub async fn run_eth_revm_cached(config: &ChainConfig) -> Result<()> {
    // 1Ô∏è‚É£ T·∫°o JSON-RPC provider ƒë·ªÉ l·∫•y pool/quoter bytecode th·∫≠t
    let provider = ProviderBuilder::new()
        .on_http(config.rpc_url.parse()?);
    let provider = Arc::new(provider);

    // 2Ô∏è‚É£ T·∫°o cache db t·ª´ REVM memory
    let mut cache_db = init_cache_db(provider.clone());

    // 3Ô∏è‚É£ ƒê·ªãa ch·ªâ c·∫ßn d√πng
    let from = config.addr("ME")?;
    let token_in = config.addr("WETH")?;
    let token_out = config.addr("USDC")?;
    let quoter = config.addr("QUOTER")?;
    let pool = config.addr("POOL_3000")?;

    // 4Ô∏è‚É£ Chu·∫©n b·ªã volume ƒë·ªÉ benchmark
    let volumes = volumes(U256::ZERO, ONE_ETHER.div(U256::from(10)), 100);

    // 5Ô∏è‚É£ T·∫£i bytecode th·∫≠t cho quoter + pool v√†o memory state
    init_account(quoter, &mut cache_db, provider.clone()).await?;
    init_account(pool, &mut cache_db, provider.clone()).await?;

    // 6Ô∏è‚É£ T·∫£i bytecode ERC20 gi·∫£
    let mocked_erc20 = include_str!("../bytecode/generic_erc20.hex");
    let mocked_erc20 = Bytes::from_str(mocked_erc20)?;
    let mocked_erc20 = Bytecode::new_raw(mocked_erc20);

    // 7Ô∏è‚É£ G√°n bytecode gi·∫£ cho token (WETH, USDC)
    init_account_with_bytecode(token_in, mocked_erc20.clone(), &mut cache_db)?;
    init_account_with_bytecode(token_out, mocked_erc20.clone(), &mut cache_db)?;

    // 8Ô∏è‚É£ G√°n balance gi·∫£ trong storage
    let mocked_balance = U256::MAX / U256::from(2);
    insert_mapping_storage_slot(token_in, U256::ZERO, pool, mocked_balance, &mut cache_db)?;
    insert_mapping_storage_slot(token_out, U256::ZERO, pool, mocked_balance, &mut cache_db)?;

    // 9Ô∏è‚É£ Quote l·∫ßn ƒë·∫ßu
    let start = measure_start("revm_cached_first");
    let calldata = quote_calldata(token_in, token_out, volumes[0], 3000);
    let response = revm_call(from, quoter, calldata, &mut cache_db)?;
    let amount_out = decode_quote_response(response)?;
    println!("{} WETH -> USDC {}", volumes[0], amount_out);
    measure_end(start);

    // üîü Quote nhi·ªÅu volume ƒë·ªÉ test hi·ªáu su·∫•t
    let start = measure_start("revm_cached_loop");
    for (index, volume) in volumes.into_iter().enumerate() {
        let calldata = quote_calldata(token_in, token_out, volume, 3000);
        let response = revm_call(from, quoter, calldata, &mut cache_db)?;
        let amount_out = decode_quote_response(response)?;
        if index % 20 == 0 {
            println!("{} WETH -> USDC {}", volume, amount_out);
        }
    }
    measure_end(start);

    Ok(())
}



==================== src/core/revm_quoter.rs ====================
use std::sync::Arc;
use std::ops::Div;
use std::str::FromStr;
use anyhow::Result;
use alloy::{
    primitives::{Bytes, U256},
    providers::ProviderBuilder,
};
use revm::primitives::Bytecode;

use crate::types::{ChainConfig, ONE_ETHER};
use crate::source::{builder::volumes, abi::*};
use crate::core::db::*;
use crate::core::logger::{measure_start, measure_end};

/// REVM ch·∫°y quote b·∫±ng custom UniV3Quoter contract (tr·∫£ k·∫øt qu·∫£ trong revert)
pub async fn run_eth_revm_quoter(config: &ChainConfig) -> Result<()> {
    // 1Ô∏è‚É£ Kh·ªüi t·∫°o provider v√† cache_db
    let provider = ProviderBuilder::new()
        .on_http(config.rpc_url.parse()?);
    let provider = Arc::new(provider);
    // T·∫°o REVM cache database t·ª´ provider
    let mut cache_db = init_cache_db(provider.clone());

    // 2Ô∏è‚É£ ƒê·ªçc address t·ª´ config
    let from = config.addr("ME")?;
    let token_in = config.addr("WETH")?;
    let token_out = config.addr("USDC")?;
    let pool = config.addr("POOL_3000")?;
    let quoter = config.addr("CUSTOM_QUOTER")?;

    // 3Ô∏è‚É£ Chu·∫©n b·ªã volume ƒë·ªÉ benchmark
    let volumes = volumes(U256::ZERO, ONE_ETHER.div(U256::from(10)), 100);

    // 4Ô∏è‚É£ Load bytecode th·∫≠t v√† gi·∫£ v√†o REVM
    init_account(from, &mut cache_db, provider.clone()).await?;
    init_account(pool, &mut cache_db, provider.clone()).await?;

    let mocked_erc20 = include_str!("../bytecode/generic_erc20.hex");
    let mocked_erc20 = Bytecode::new_raw(Bytes::from_str(mocked_erc20)?);
    init_account_with_bytecode(token_in, mocked_erc20.clone(), &mut cache_db)?;
    init_account_with_bytecode(token_out, mocked_erc20.clone(), &mut cache_db)?;

    // 5Ô∏è‚É£ Insert fake balances v√†o REVM storage
    let mocked_balance = U256::MAX / U256::from(2);
    insert_mapping_storage_slot(token_in, U256::ZERO, pool, mocked_balance, &mut cache_db)?;
    insert_mapping_storage_slot(token_out, U256::ZERO, pool, mocked_balance, &mut cache_db)?;

    // 6Ô∏è‚É£ Load custom quoter bytecode (tr·∫£ k·∫øt qu·∫£ qua revert)
    let mocked_custom_quoter = include_str!("../bytecode/uni_v3_quoter.hex");
    let mocked_custom_quoter = Bytecode::new_raw(Bytes::from_str(mocked_custom_quoter)?);
    init_account_with_bytecode(quoter, mocked_custom_quoter, &mut cache_db)?;

    // 7Ô∏è‚É£ Quote ƒë·∫ßu ti√™n
    let start = measure_start("revm_quoter_first");
    let calldata = get_amount_out_calldata(pool, token_in, token_out, volumes[0]);
    let response = revm_revert(from, quoter, calldata, &mut cache_db)?;
    let amount_out = decode_get_amount_out_response(response)?;
    println!("{} WETH -> USDC {}", volumes[0], amount_out);
    measure_end(start);

    // 8Ô∏è‚É£ Loop benchmark c√°c volume c√≤n l·∫°i
    let start = measure_start("revm_quoter_loop");
    for (index, volume) in volumes.into_iter().enumerate() {
        let calldata = get_amount_out_calldata(pool, token_in, token_out, volume);
        let response = revm_revert(from, quoter, calldata, &mut cache_db)?;
        let amount_out = decode_get_amount_out_response(response)?;
        if index % 20 == 0 {
            println!("{} WETH -> USDC {}", volume, amount_out);
        }
    }
    measure_end(start);

    Ok(())
}



==================== src/core/revm.rs ====================
use std::sync::Arc;
use std::ops::Div;
use anyhow::Result;
use alloy::{
    primitives::U256,
    providers::{ProviderBuilder, RootProvider},
    transports::http::{Http, Client},
};

use crate::types::{ChainConfig, ONE_ETHER};
use crate::source::{builder::volumes, abi::*};
use crate::core::db::{init_cache_db, init_account, revm_call};
use crate::core::logger::{measure_start, measure_end};

/// M√¥ ph·ªèng quote swap t·ª´ UniswapV3 b·∫±ng `REVM` (EVM gi·∫£ l·∫≠p offchain)
/// D√πng calldata quoteExactInputSingle() v√† simulate b·∫±ng REVM tr√™n memory state
pub async fn run_eth_revm(config: &ChainConfig) -> Result<()> {
    // 1Ô∏è‚É£ Kh·ªüi t·∫°o JSON-RPC provider ƒë·ªÉ fetch bytecode t·ª´ chain th·ª±c
    let provider = ProviderBuilder::new()
        .on_http(config.rpc_url.parse()?);
    let provider = Arc::new(provider);

    // 2Ô∏è‚É£ T·∫°o REVM CacheDB t·ª´ provider chain th·ª±c
    let mut cache_db = init_cache_db(provider.clone());

    // 3Ô∏è‚É£ ƒê·ªãa ch·ªâ d√πng trong giao d·ªãch (t·ª´ config)
    let from = config.addr("ME")?;
    let token_in = config.addr("WETH")?;
    let token_out = config.addr("USDC")?;
    let quoter = config.addr("QUOTER")?;

    // 4Ô∏è‚É£ Chu·∫©n b·ªã volume swap ƒë·ªÉ benchmark
    let volumes = volumes(U256::ZERO, ONE_ETHER.div(U256::from(10)), 100);

    // 5Ô∏è‚É£ T·∫£i bytecode c·ªßa contract quoter v√†o REVM memory state
    init_account(quoter, &mut cache_db, provider.clone()).await?;

    // 6Ô∏è‚É£ M√¥ ph·ªèng l·∫ßn ƒë·∫ßu: WETH ‚Üí USDC v·ªõi volume ƒë·∫ßu ti√™n
    let start = measure_start("revm_first");
    let calldata = quote_calldata(token_in, token_out, volumes[0], 3000);
    let response = revm_call(from, quoter, calldata, &mut cache_db)?;
    let amount_out = decode_quote_response(response)?;
    println!("{} WETH -> USDC {}", volumes[0], amount_out);
    measure_end(start);

    // 7Ô∏è‚É£ M√¥ ph·ªèng l·∫∑p nhi·ªÅu volume ƒë·ªÉ benchmark hi·ªáu su·∫•t
    let start = measure_start("revm_loop");
    for (index, volume) in volumes.into_iter().enumerate() {
        let calldata = quote_calldata(token_in, token_out, volume, 3000);
        let response = revm_call(from, quoter, calldata, &mut cache_db)?;
        let amount_out = decode_quote_response(response)?;

        if index % 20 == 0 {
            println!("{} WETH -> USDC {}", volume, amount_out);
        }
    }
    measure_end(start);

    Ok(())
}



==================== src/core/validate.rs ====================
use std::sync::Arc;
use std::ops::{Div, Mul};
use std::str::FromStr;
use anyhow::Result;
use alloy::providers::Provider;
use alloy::{
    primitives::{Bytes, U256},
    providers::ProviderBuilder,
};
use revm::primitives::Bytecode;

use crate::types::{ChainConfig, ONE_ETHER};
use crate::source::{builder::volumes, abi::*, builder::build_tx};
use crate::core::db::*;

/// So s√°nh k·∫øt qu·∫£ quote t·ª´ `eth_call` v√† `revm`
/// D√πng custom UniV3Quoter ƒë·ªÉ ƒë·∫£m b·∫£o REVM ph·∫£n h·ªìi `amountOut` ƒë√∫ng
pub async fn run_eth_validate(config: &ChainConfig) -> Result<()> {
    // 1Ô∏è‚É£ Setup RPC v√† provider
    let provider = ProviderBuilder::new()
        .on_http(config.rpc_url.parse()?);
    let provider = Arc::new(provider);
    // T·∫°o REVM cache database t·ª´ provider

    let mut cache_db = init_cache_db(provider.clone());

    let base_fee = provider.get_gas_price().await?;
    let base_fee = base_fee.mul(110).div(100); // +10% ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n fee

    // 2Ô∏è‚É£ Load address t·ª´ config
    let from = config.addr("ME")?;
    let token_in = config.addr("WETH")?;
    let token_out = config.addr("USDC")?;
    let pool = config.addr("POOL_3000")?;
    let quoter = config.addr("QUOTER")?;
    let custom_quoter = config.addr("CUSTOM_QUOTER")?;

    // 3Ô∏è‚É£ Chu·∫©n b·ªã volume v√† mock data
    let volumes = volumes(U256::ZERO, ONE_ETHER.div(U256::from(10)), 10);

    init_account(from, &mut cache_db, provider.clone()).await?;
    init_account(pool, &mut cache_db, provider.clone()).await?;

    let mocked_erc20 = include_str!("../bytecode/generic_erc20.hex");
    let mocked_erc20 = Bytecode::new_raw(Bytes::from_str(mocked_erc20)?);
    init_account_with_bytecode(token_in, mocked_erc20.clone(), &mut cache_db)?;
    init_account_with_bytecode(token_out, mocked_erc20.clone(), &mut cache_db)?;

    let mocked_balance = U256::MAX / U256::from(2);
    insert_mapping_storage_slot(token_in, U256::ZERO, pool, mocked_balance, &mut cache_db)?;
    insert_mapping_storage_slot(token_out, U256::ZERO, pool, mocked_balance, &mut cache_db)?;

    let mocked_custom_quoter = include_str!("../bytecode/uni_v3_quoter.hex");
    let mocked_custom_quoter = Bytecode::new_raw(Bytes::from_str(mocked_custom_quoter)?);
    init_account_with_bytecode(custom_quoter, mocked_custom_quoter, &mut cache_db)?;

    // 4Ô∏è‚É£ So s√°nh t·ª´ng volume
    for volume in volumes {
        let call_calldata = quote_calldata(token_in, token_out, volume, 3000);
        let tx = build_tx(quoter, from, call_calldata, base_fee);
        let call_response = provider.call(&tx).await?;
        let call_amount_out = decode_quote_response(call_response)?;

        let revm_calldata = get_amount_out_calldata(pool, token_in, token_out, volume);
        let revm_response = revm_revert(from, custom_quoter, revm_calldata, &mut cache_db)?;
        let revm_amount_out = decode_get_amount_out_response(revm_response)?;

        println!(
            "{} WETH -> USDC | REVM: {} | ETH_CALL: {}",
            volume, revm_amount_out, call_amount_out
        );

        // 5Ô∏è‚É£ X√°c minh ch√≠nh x√°c
        assert_eq!(revm_amount_out, call_amount_out);
    }

    Ok(())
}



